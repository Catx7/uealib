#summary Некоторые размышления по поводу архитектуры

Насколько я понимаю, цель унификации интерфейсов — сделать их взаимозаменяемыми.
Так, чтобы пользователь мог реализовать свои Solution, Initializator, Generator, Evaluator, "подставить" их в любой из наших алгоритмов и получить решение.

=Первая проблема=
В поиске с табу мне довольно неудобно использовать Generator, который возвращает поколения. В моём случае довольно удобно (и производительно) выделить абстракцию Move, и заставить Generator возвращать {{{ Pair<Solution, List<Move>> }}}.
Move в моём коде используется не только в генераторе, но и в множестве других классов (FrequencyMemory, Taboolator, Evaluator, AdmissibleChecker), и отказаться от его использования я не могу.

Выходит, что мы имеем два генератора:

1)
{{{
public interface Generator<T extends Generation<? extends Solution>> {
	public T getNext(T g);
}}}

2)
{{{
public interface Generator<S extends Solution, M extends Move<S>, G extends Generation<S>> {
	public Pair<S, List<M>> getNext(G g);
}
}}}
Можно оба добавить в пакет core, хотя в таком случае мы потеряем совместимость по интерфейсам, к которой так стремимся.

Первый генератор привести к виду второго невозможно.

Второй генератор привести к виду первого легко; первому достаточно стать декоратором для второго. Как-нибудь так:

{{{ 
public interface Generator<T extends Generation<? extends Solution>> {
    public T getNext(T g) {
        Pair<S, List<M>> boundMoves = ...getNext второго генератора...
        solution = moves.getFirst()
        moves = moves.getSecond()
        for (move : moves) {
        	generation.add(move.operateOn(solution))
        }
        return generation
    }
}}}


Таким образом, если пользовать написал Generator в терминах Move, он может легко получить Generator в терминах Generation, если ему это необходимо (для дифференциальной эволюции, например).
Обратное неверно: поиск с табу не может работать Generator, возвращающим Generation.

=Вторая проблема=
Допустим, пользователь написал генератор второго типа (возвращающий {{{ Pair<S, List<M> }}}), ориентируясь на поиск с табу. Генератор ожидает на вход поколения из _одного_ решения, и возвращает нечто, что можно назвать окрестностью этого одного решения.

Как было описано ранее, пользователь может легко превратить генератор второго типа в генератор первого типа. Допустим, он сделал это и теперь хочет использовать получившийся в результате генератор в алгоритме дифференциальной эволюции. Я крайне сомневаюсь, что у него что-то заработает :) Потому что:

Генератор для ДЭ:
http://code.google.com/p/uealib/source/browse/branches/new_interfaces/src/diffevolution/tsp/TSPGenerator.java?r=70

Генератор для поиска с табу:
http://code.google.com/p/uealib/source/browse/branches/new_interfaces/src/taboosearch/permutations/Generator.java?r=58

Несмотря на одинаковые интерфейсы, они выполняют разные функции. В алгоритме поиска с табу генератор возвращает окрестность решения (принимая на вход "вырожденное" поколение, всегда содержащее одно решение).

В дифференциальной эволюции же генератор выполняет какие-то нетривиальные действия и, по сути, является основной частью алгоритма. Переданное ему поколение должно содержать как минимум три решения.

Аргументировать я явно не умею :), но, по-моему, очевидно, что генераторы дифференциальной эволюции и поиска с табу не будут взаимозаменяемы, даже если будут предоставлять один и тот же интерфейс.